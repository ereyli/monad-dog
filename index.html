<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monad Dog</title>

<!-- Supabase Client -->
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <!-- Farcaster Manifest Link -->
  <link rel="manifest" href="/farcaster.json">
  <link rel="icon" type="image/png" href="https://monad-snowy.vercel.app/.well-known/icon.png">
  
  <!-- Farcaster Meta with Dynamic Content -->
  <meta name="fc:frame" content='{
    "version": "next",
    "imageUrl": "https://monad-snowy.vercel.app/.well-known/share.png",
    "button": {
      "title": "🐕 Play Monad Dog",
      "action": {
        "type": "launch_frame",
        "url": "https://monad-snowy.vercel.app",
        "name": "Monad Dog",
        "splashImageUrl": "https://monad-snowy.vercel.app/.well-known/icon.png",
        "splashBackgroundColor": "#1e003e"
      }
    }
  }' />

  <!-- Open Graph for better sharing -->
  <meta property="og:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta property="og:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta property="og:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />
  <meta property="og:url" content="https://monad-snowy.vercel.app" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta name="twitter:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta name="twitter:image" content="https://monad-snowy.vercel.app/.well-known/share.png" />

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <!-- Farcaster Mini App SDK -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/frame-sdk';
    
    // Mini App ready when loaded
    window.addEventListener('load', async () => {
      try {
        await sdk.actions.ready();
        console.log('Farcaster Mini App ready!');
        
        // Make SDK available globally
        window.farcasterSDK = sdk;
      } catch (error) {
        console.log('Not running in Farcaster client:', error);
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 400px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .xp {
      background: rgba(255,255,255,0.1);
      padding: 10px 20px;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 20px;
    }
    
    .wallet-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin: 10px 0;
    }
    
    button:hover {
      background: #5855e8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tabs {
      display: flex;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    .tab {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    
    .tab.active {
      background: #6366f1;
    }
    
    .content {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      min-height: 200px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .dog-image {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      margin: 20px auto;
      display: block;
    }
    
    .coin {
      font-size: 60px;
      margin: 20px;
      transition: transform 0.5s;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      display: none;
    }
    
    .status.visible {
      display: block;
    }
    
    .status.success {
      background: rgba(0,255,0,0.2);
      color: #00ff00;
    }
    
    .status.error {
      background: rgba(255,0,0,0.2);
      color: #ff6b6b;
    }
    
    .status.pending {
      background: rgba(255,255,0,0.2);
      color: #ffeb3b;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      color: white;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      border-top-color: #6366f1;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    .loading-subtitle {
      font-size: 14px;
      opacity: 0.7;
      text-align: center;
      max-width: 280px;
      line-height: 1.4;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      margin-top: 20px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Skeleton Loading States */
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-text {
      height: 16px;
      border-radius: 4px;
      margin: 8px 0;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .skeleton-button {
      height: 44px;
      border-radius: 8px;
      margin: 10px 0;
    }

    /* Hide content initially to prevent layout shift */
    .app-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .app-content.loaded {
      opacity: 1;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    
    th {
      background: rgba(255,255,255,0.1);
    }
    
    .address {
      font-family: monospace;
      font-size: 12px;
    }

    .badge {
      background: #ff6b9d;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 8px;
    }

    .rank-number {
      font-weight: 600;
      color: #6366f1;
      width: 40px;
    }

    .address-cell {
      font-family: monospace;
      font-size: 12px;
    }

    .share-button {
      background: linear-gradient(45deg, #6366f1, #8b5cf6);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin: 10px 5px;
      width: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .share-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
    }

    .share-section {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .achievement-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    .achievement-content {
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 350px;
      border: 2px solid #6366f1;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }

    .achievement-icon {
      font-size: 60px;
      margin-bottom: 15px;
      animation: bounce 0.6s ease;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      width: auto;
      padding: 5px;
    }

    /* Token Claim Styles */
    .token-stats {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      padding: 8px 16px;
      border-radius: 20px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
      font-size: 14px;
      font-weight: 600;
    }

    .claim-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .claim-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .claim-info-item {
      text-align: center;
    }

    .claim-info-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .claim-info-value {
      font-size: 20px;
      font-weight: 600;
      color: #f59e0b;
    }

    .claim-button {
      background: linear-gradient(135deg, #f59e0b, #eab308);
      color: white;
      font-weight: 600;
      padding: 14px 28px;
      border-radius: 12px;
      width: 100%;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .claim-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
    }

    .claim-button:disabled {
      background: rgba(255,255,255,0.1);
      cursor: not-allowed;
    }

    .token-balance {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
      padding: 10px;
      background: rgba(245, 158, 11, 0.1);
      border-radius: 8px;
      font-size: 14px;
    }

    .conversion-rate {
      text-align: center;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 8px;
    }

    .claim-history {
      margin-top: 20px;
      font-size: 12px;
      opacity: 0.7;
    }

    .claim-history-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
  </style>
</head>
<body>
  <div class="container app-content">
    <div class="header">
      <div class="title">🐕 Monad Dog</div>
      <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
        <div class="xp">✨ XP: <span id="xp">0</span></div>
        <div class="token-stats">🪙 $DOG: <span id="dogTokenBalance">0</span></div>
      </div>
    </div>

    <div class="wallet-section">
      <div id="connect-area">
        <button id="connect-btn">🟣 Connect Wallet</button>
      </div>
      <div id="connected-area" style="display: none;">
        <div>🟣 Connected</div>
        <div id="address" class="address"></div>
        <button id="disconnect-btn">Disconnect</button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="showTab('pet')">🐕 Pet</button>
      <button class="tab" onclick="showTab('greet')">👋 Greet</button>
      <button class="tab" onclick="showTab('flip')">🪙 Flip</button>
      <button class="tab" onclick="showTab('claim')">💰 Claim</button>
    </div>

    <div class="content">
      <!-- Pet Tab -->
      <div id="pet" class="tab-content active">
        <h3>Pet the Dog</h3>
        <img id="dog-img" class="dog-image" src="https://placedog.net/400/300?id=7" alt="Dog">
        <button onclick="petDog()">👋 Pet Dog (+10 XP)</button>
        <div id="pet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="sharePetAchievement()">
            🐕 Share Pet Achievement
          </button>
        </div>
      </div>

      <!-- Greet Tab -->
      <div id="greet" class="tab-content">
        <h3>Greet Community</h3>
        <p>Say GM or GN to the community!</p>
        <button onclick="sayGM()">☀️ Good Morning (+5 XP)</button>
        <button onclick="sayGN()">🌙 Good Night (+5 XP)</button>
        <div id="greet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareGreetAchievement()">
            👋 Share Community Spirit
          </button>
        </div>
      </div>

      <!-- Flip Tab -->
      <div id="flip" class="tab-content">
        <h3>Flip Coin</h3>
        <div class="coin" id="coin">🪙</div>
        <button onclick="flipCoin()">🎲 Flip Coin (+3 XP)</button>
        <div id="flip-result">Result will appear here</div>
        <div id="flip-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareFlipAchievement()">
            🪙 Share Lucky Moment
          </button>
        </div>
      </div>

      <!-- Claim Tab -->
      <div id="claim" class="tab-content">
        <h3>Claim $DOG Tokens</h3>
        <p style="margin-bottom: 20px;">Convert your earned XP to $DOG tokens!</p>
        
        <div class="claim-section">
          <div class="claim-info">
            <div class="claim-info-item">
              <div class="claim-info-label">Available XP</div>
              <div class="claim-info-value" id="claimableXP">0</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">→</div>
              <div style="font-size: 30px;">🔄</div>
            </div>
            <div class="claim-info-item">
              <div class="claim-info-label">$DOG Tokens</div>
              <div class="claim-info-value" id="claimableDOG">0</div>
            </div>
          </div>
          
          <button class="claim-button" id="claimButton" onclick="claimTokens()" disabled>
            💰 Claim $DOG Tokens
          </button>
          
          <div class="conversion-rate">
            Conversion Rate: 10 XP = 1 $DOG
          </div>
          
          <div id="claim-status" class="status"></div>
        </div>
        
        <div class="token-balance">
          <span>Your $DOG Balance:</span>
          <strong id="userDogBalance">0</strong>
          <span>$DOG</span>
        </div>
        
        <!-- Token Info -->
        <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 12px;">
          <div style="text-align: center; margin-bottom: 15px;">
            <h4 style="margin-bottom: 10px;">🐕 $DOG Token Info</h4>
            <p style="font-size: 12px; opacity: 0.7;">Claim your tokens and they'll be minted directly to your wallet</p>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;">
              <div style="opacity: 0.7; font-size: 12px;">Total Claimed</div>
              <div id="totalClaimedXP" style="font-weight: 600; color: #f59e0b;">0 XP</div>
            </div>
            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;">
              <div style="opacity: 0.7; font-size: 12px;">Total $DOG</div>
              <div id="totalDogClaimed" style="font-weight: 600; color: #f59e0b;">0 $DOG</div>
            </div>
          </div>
          
          <div style="margin-top: 15px; padding: 10px; background: rgba(245, 158, 11, 0.1); border-radius: 8px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 12px;">
              <span style="opacity: 0.7;">Max Supply:</span>
              <span style="font-weight: 600;">10,000,000 $DOG</span>
            </div>
            
            <!-- Progress Bar -->
            <div style="margin-bottom: 5px;">
              <div style="background: rgba(255,255,255,0.1); border-radius: 8px; height: 20px; position: relative; overflow: hidden;">
                <div id="claimedProgressBar" style="background: linear-gradient(90deg, #f59e0b, #dc2626); height: 100%; width: 0%; transition: width 0.5s ease;"></div>
                <span id="claimedProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 11px; font-weight: 600; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">
                  0 / 10M
                </span>
              </div>
            </div>
            
            <div style="text-align: center; font-size: 11px; opacity: 0.7;">
              Claimed: <span id="totalClaimedAmount" style="color: #f59e0b; font-weight: 600;">0</span> $DOG
            </div>
          </div>
          
          <div style="margin-top: 15px; text-align: center;">
            <a href="https://testnet.monadscan.com/address/0x1f6649d028c4c146c050a9b224115a01c92a02f3" 
               target="_blank" 
               class="share-button" 
               style="background: rgba(255,255,255,0.1); font-size: 12px; padding: 8px 16px;">
              🔍 View Token Contract
            </a>
          </div>
        </div>
        
        <div class="claim-history" id="claimHistory" style="margin-top: 20px;">
          <!-- Claim history will be populated here -->
        </div>
      </div>
    </div>

    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading Monad Dog...</div>
      <div class="loading-subtitle">Starting Monad Dog...<br>🚀 Initializing blockchain connection</div>
      <div class="loading-progress">
        <div class="loading-progress-bar" id="loadingProgressBar"></div>
      </div>
    </div>

    <!-- Achievement Modal -->
    <div id="achievementModal" class="achievement-modal">
      <div class="achievement-content">
        <button class="close-modal" onclick="closeAchievementModal()">×</button>
        <div id="achievementIcon" class="achievement-icon">🎉</div>
        <h3 id="achievementTitle">Achievement Unlocked!</h3>
        <p id="achievementDescription">You did something awesome!</p>
        <div style="margin-top: 20px;">
          <button class="share-button" onclick="shareCurrentAchievement()">
            📢 Share on Farcaster
          </button>
          <button class="share-button" onclick="closeAchievementModal()" style="background: rgba(255,255,255,0.2);">
            ✨ Continue Playing
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Wait for Supabase to load
    window.addEventListener('DOMContentLoaded', function() {
      // Supabase Configuration
      const SUPABASE_URL = 'https://uhqszfoekqrjtybrwqzt.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVocXN6Zm9la3FyanR5YnJ3cXp0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4MDMxNTAsImV4cCI6MjA2NjM3OTE1MH0.gGch8B6AlvGrZTDVjfd0xidVnh_Dsua4qRxbaixBqM0';
      
      // Initialize Supabase
      let supabaseClient;
      if (window.supabase) {
        const { createClient } = window.supabase;
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('✅ Supabase initialized');
      } else {
        console.error('❌ Supabase not loaded');
      }
    
    console.log('🚀 Starting app...');
    
    // Enhanced Loading Management
    let loadingProgress = 0;
    let isAppReady = false;
    let activeTab = 'pet';

    function updateLoadingProgress(progress, message) {
      const progressBar = document.getElementById('loadingProgressBar');
      const subtitle = document.querySelector('.loading-subtitle');
      
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
      
      if (subtitle && message) {
        subtitle.innerHTML = message;
      }
      
      loadingProgress = progress;
      console.log(`📊 Loading progress: ${progress}% - ${message}`);
    }

    function showLoadingState() {
      document.getElementById('loading').style.display = 'flex';
      document.querySelector('.app-content').classList.remove('loaded');
      updateLoadingProgress(0, 'Starting Monad Dog...<br>🚀 Initializing blockchain connection');
    }

    function hideLoadingState() {
      // Don't hide immediately - show completion
      updateLoadingProgress(100, 'Ready to play! 🎉<br>Welcome to Monad Dog!');
      
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.querySelector('.app-content').classList.add('loaded');
        isAppReady = true;
        
        // Call Farcaster ready action
        if (sdk && sdk.actions && sdk.actions.ready) {
          sdk.actions.ready({
            disableNativeGestures: false // Allow native gestures for better UX
          }).then(() => {
            console.log('✅ Farcaster SDK ready called successfully');
          }).catch(error => {
            console.log('⚠️ Farcaster SDK ready failed:', error);
          });
        }
        
        console.log('🎉 App fully loaded and ready');
      }, 500);
    }

    // Simulate progressive loading with actual initialization steps
    async function initializeAppWithProgress() {
      try {
        showLoadingState();
        
        // Step 1: Initialize SDK
        updateLoadingProgress(20, 'Loading Farcaster SDK...<br>🔗 Connecting to Frame environment');
        
        try {
          const module = await import('https://esm.sh/@farcaster/frame-sdk');
          sdk = module.sdk;
          console.log('SDK loaded:', !!sdk);
          
          if (sdk) {
            updateLoadingProgress(40, 'Farcaster SDK loaded! ✅<br>📱 Setting up Mini App environment');
            await sdk.actions.ready();
            console.log('SDK ready');
          }
        } catch (e) {
          console.log('SDK not available:', e.message);
          updateLoadingProgress(40, 'Running in standalone mode<br>🌐 Browser environment detected');
        }

        // Step 2: Setup game functions
        updateLoadingProgress(60, 'Setting up game functions...<br>🎮 Preparing blockchain interactions');
        await new Promise(resolve => setTimeout(resolve, 300)); // Small delay for UX
        
        setupEventListeners();
        setupGameFunctions();
        
        // Step 3: Load leaderboard from Supabase
        updateLoadingProgress(80, 'Loading leaderboard data...<br>🏆 Fetching player rankings');
        await populateLeaderboard();
        
        // Step 4: Finalize
        updateLoadingProgress(95, 'Almost ready...<br>✨ Final preparations');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        hideLoadingState();
        console.log('✅ App initialized successfully with progress tracking');
        
      } catch (error) {
        console.error('❌ Init error:', error);
        updateLoadingProgress(100, 'Error occurred, but app will continue<br>⚠️ Some features may be limited');
        
        setTimeout(() => {
          hideLoadingState();
        }, 1000);
      }
    }

    // Enhanced error handling for better loading experience
    function handleLoadingError(error, step) {
      console.error(`❌ Loading error at step "${step}":`, error);
      
      const errorMessages = {
        sdk: 'SDK loading failed<br>🌐 Continuing in browser mode',
        functions: 'Function setup error<br>⚠️ Some features may be limited',
        leaderboard: 'Leaderboard loading failed<br>📊 Will retry automatically',
        general: 'Loading error occurred<br>🔄 Attempting to continue'
      };
      
      const message = errorMessages[step] || errorMessages.general;
      updateLoadingProgress(loadingProgress, message);
      
      // Continue loading after brief delay
      setTimeout(() => {
        if (loadingProgress < 100) {
          hideLoadingState();
        }
      }, 1500);
    }

    // Skeleton loading for leaderboard while data loads
    function showLeaderboardSkeleton() {
      const tbody = document.getElementById('leaderboardBody');
      if (!tbody) return;
      
      const skeletonRows = Array.from({length: 5}, (_, i) => `
        <tr>
          <td class="rank-number skeleton skeleton-text" style="width: 30px;"></td>
          <td class="address-cell">
            <div class="skeleton skeleton-text" style="width: 120px;"></div>
            <div class="skeleton skeleton-text" style="width: 80px; margin-top: 4px;"></div>
          </td>
          <td class="tx-count skeleton skeleton-text" style="width: 40px;"></td>
        </tr>
      `).join('');
      
      tbody.innerHTML = skeletonRows;
    }

    // Preload critical resources
    function preloadResources() {
      // Preload dog images for faster switching
      const dogImages = [1, 7, 12, 15, 23, 28, 34, 42, 47, 53];
      dogImages.forEach(id => {
        const img = new Image();
        img.src = `https://placedog.net/400/300?id=${id}`;
      });
      
      console.log('🖼️ Preloaded dog images for better performance');
    }

    // Contract addresses and ABIs
    const CONTRACTS = {
      PET: "0xc53abe4c593b9440407f8ac1b346f3f999e6d8ed",
      GREET: "0xbc8b78f3e2348d4b5e0390fe700ce54b59931da4",
      FLIP: "0xc5b2280d1e2f155f9a2be2af7e78190658874106",
      DOG_TOKEN: "0x1f6649d028c4c146c050a9b224115a01c92a02f3" // Your deployed DOG token contract
    };

    const ABIS = {
      PET: ["function pet() public"],
      GREET: ["function gm() public", "function gn() public"],
      FLIP: ["function flip() public"],
      DOG_TOKEN: [
        "function claim(uint256 xpAmount) public",
        "function balanceOf(address account) public view returns (uint256)",
        "function decimals() public view returns (uint8)",
        "function symbol() public view returns (string)",
        "function totalSupply() public view returns (uint256)",
        "function getClaimedXP(address user) public view returns (uint256)",
        "function totalMinted() public view returns (uint256)",
        "event TokensClaimed(address indexed user, uint256 xpAmount, uint256 tokenAmount)"
      ]
    };

    // XP to DOG token conversion rate
    const XP_TO_DOG_RATE = 10; // 10 XP = 1 DOG token

    // Supabase Functions for XP Management - with error handling and fallback
    async function getWalletXP(address) {
      if (!address) return 0;
      
      try {
        // Check if Supabase is available
        if (!supabaseClient) {
          console.log('Supabase not available, using localStorage fallback');
          return parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
        }

        const { data, error } = await supabaseClient
          .from('user_xp')
          .select('xp')
          .eq('wallet_address', address.toLowerCase())
          .single();
        
        if (error) {
          console.log('No XP record found, returning 0');
          // Fallback to localStorage
          return parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
        }
        
        return data.xp || 0;
      } catch (e) {
        console.error('Error fetching XP:', e);
        // Fallback to localStorage
        return parseInt(localStorage.getItem(`wallet_xp_${address.toLowerCase()}`) || '0');
      }
    }

    async function saveWalletXP(address, xp) {
      if (!address) return;
      
      // Always save to localStorage first (immediate)
      localStorage.setItem(`wallet_xp_${address.toLowerCase()}`, xp.toString());
      
      // Then try Supabase (async, non-blocking)
      if (supabaseClient) {
        supabaseClient
          .from('user_xp')
          .upsert({
            wallet_address: address.toLowerCase(),
            xp: xp,
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'wallet_address'
          })
          .then(({ error }) => {
            if (!error) {
              console.log(`💾 XP saved to Supabase for ${address}: ${xp}`);
            }
          })
          .catch(e => {
            console.error('Error saving XP to Supabase:', e);
          });
      }
    }

    // Token claim history management with Supabase - optimized
    async function getClaimHistory(address) {
      if (!address) return [];
      
      // Use localStorage as immediate fallback
      const localHistory = localStorage.getItem(`claim_history_${address.toLowerCase()}`);
      if (!supabaseClient && localHistory) {
        return JSON.parse(localHistory) || [];
      }
      
      try {
        const { data, error } = await supabaseClient
          .from('claim_history')
          .select('*')
          .eq('wallet_address', address.toLowerCase())
          .order('timestamp', { ascending: false })
          .limit(10);
        
        if (error) {
          console.error('Error fetching claim history:', error);
          return localHistory ? JSON.parse(localHistory) || [] : [];
        }
        
        return data || [];
      } catch (e) {
        console.error('Error fetching claim history:', e);
        return localHistory ? JSON.parse(localHistory) || [] : [];
      }
    }

    async function saveClaimHistory(address, claimData) {
      if (!address) return;
      
      // Save to localStorage first
      const key = `claim_history_${address.toLowerCase()}`;
      const history = JSON.parse(localStorage.getItem(key) || '[]');
      history.unshift(claimData);
      if (history.length > 10) history.pop();
      localStorage.setItem(key, JSON.stringify(history));
      
      // Then try Supabase (non-blocking)
      if (supabaseClient) {
        supabaseClient
          .from('claim_history')
          .insert({
            wallet_address: address.toLowerCase(),
            xp_amount: claimData.xpAmount,
            token_amount: claimData.tokenAmount,
            tx_hash: claimData.txHash,
            timestamp: new Date().toISOString()
          })
          .then(({ error }) => {
            if (error) {
              console.error('Error saving claim history:', error);
            }
          })
          .catch(e => {
            console.error('Error saving claim history:', e);
          });
      }
    }

    async function updateXPDisplay() {
      if (appState.connected && appState.address) {
        // Show current value immediately
        const currentDisplay = document.getElementById('xp').textContent;
        
        // Get XP (with timeout to prevent hanging)
        const xpPromise = getWalletXP(appState.address);
        const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve(parseInt(currentDisplay) || 0), 1000));
        
        const walletXP = await Promise.race([xpPromise, timeoutPromise]);
        
        document.getElementById('xp').textContent = walletXP;
        appState.xp = walletXP;
        console.log(`📊 XP loaded for ${appState.address}: ${walletXP}`);
        
        // Update claim UI non-blocking
        if (activeTab === 'claim') {
          requestAnimationFrame(() => updateClaimUI());
        }
      } else {
        document.getElementById('xp').textContent = '0';
        appState.xp = 0;
        updateClaimUI();
      }
    }

    // Update claim UI based on current XP
    async function updateClaimUI() {
      const claimableXP = appState.xp || 0;
      const claimableDOG = Math.floor(claimableXP / XP_TO_DOG_RATE);
      
      document.getElementById('claimableXP').textContent = claimableXP;
      document.getElementById('claimableDOG').textContent = claimableDOG;
      
      const claimButton = document.getElementById('claimButton');
      if (claimableXP >= XP_TO_DOG_RATE && appState.connected) {
        claimButton.disabled = false;
        claimButton.textContent = `💰 Claim ${claimableDOG} $DOG Tokens`;
      } else {
        claimButton.disabled = true;
        if (!appState.connected) {
          claimButton.textContent = '🔒 Connect Wallet First';
        } else if (claimableXP < XP_TO_DOG_RATE) {
          claimButton.textContent = `📈 Need ${XP_TO_DOG_RATE - claimableXP} more XP`;
        }
      }
      
      // Update token balance
      await updateTokenBalance();
      
      // Update claim history
      await displayClaimHistory();
    }

    // Update token balance display - Fixed version
    async function updateTokenBalance() {
      if (!appState.connected || !appState.provider) {
        document.getElementById('dogTokenBalance').textContent = '0';
        document.getElementById('userDogBalance').textContent = '0';
        return;
      }
      
      try {
        // Get real balance from contract
        const dogTokenContract = new ethers.Contract(
          CONTRACTS.DOG_TOKEN,
          ["function balanceOf(address account) public view returns (uint256)"],
          appState.provider
        );
        
        const balance = await dogTokenContract.balanceOf(appState.address);
        // DOG token has 18 decimals
        const formattedBalance = ethers.utils.formatUnits(balance, 18);
        const displayBalance = parseFloat(formattedBalance).toFixed(2);
        
        document.getElementById('dogTokenBalance').textContent = displayBalance;
        document.getElementById('userDogBalance').textContent = displayBalance;
        
        console.log(`💰 DOG Balance updated: ${displayBalance}`);
        
      } catch (error) {
        console.error('Error fetching token balance:', error);
        // Show 0 if error
        document.getElementById('dogTokenBalance').textContent = '0';
        document.getElementById('userDogBalance').textContent = '0';
      }
    }

    // Display claim history
    async function displayClaimHistory() {
      if (!appState.connected || !appState.address) {
        document.getElementById('claimHistory').innerHTML = '';
        return;
      }
      
      const history = await getClaimHistory(appState.address);
      const historyContainer = document.getElementById('claimHistory');
      
      if (history.length === 0) {
        historyContainer.innerHTML = '<div style="text-align: center; opacity: 0.5;">No claim history yet</div>';
        return;
      }
      
      historyContainer.innerHTML = '<h4 style="margin-bottom: 10px;">Recent Claims</h4>' +
        history.map(claim => `
          <div class="claim-history-item">
            <span>${new Date(claim.timestamp).toLocaleDateString()}</span>
            <span>${claim.xp_amount} XP → ${claim.token_amount} $DOG</span>
          </div>
        `).join('');
    }

    // Claim tokens function
    window.claimTokens = async function() {
      if (!appState.connected || !appState.signer) {
        showError('Please connect your wallet first');
        return;
      }
      
      const claimableXP = appState.xp;
      const claimableDOG = Math.floor(claimableXP / XP_TO_DOG_RATE);
      
      if (claimableXP < XP_TO_DOG_RATE) {
        showError(`Need at least ${XP_TO_DOG_RATE} XP to claim tokens`);
        return;
      }
      
      try {
        console.log('💰 Starting token claim...');
        showStatus('claim-status', '🔐 Please confirm transaction in your wallet...', 'pending');
        
        // Ensure correct network
        await ensureMonadNetwork();
        
        // Call the actual DOG token contract
        const dogTokenContract = new ethers.Contract(
          CONTRACTS.DOG_TOKEN,
          ABIS.DOG_TOKEN,
          appState.signer
        );
        
        // Calculate XP to claim (must be multiple of 10)
        const xpToClaim = claimableDOG * XP_TO_DOG_RATE;
        
        console.log(`Claiming ${xpToClaim} XP for ${claimableDOG} DOG tokens`);
        
        // Execute claim transaction with proper gas limit
        const tx = await dogTokenContract.claim(xpToClaim, {
          gasLimit: 500000 // Set appropriate gas limit
        });
        
        showStatus('claim-status', `📡 Transaction sent: ${tx.hash.slice(0,10)}...`, 'pending');
        console.log('Transaction hash:', tx.hash);
        
        // Wait for confirmation (but don't wait too long for Farcaster wallet)
        setTimeout(async () => {
          try {
            // Update local XP
            const remainingXP = claimableXP - xpToClaim;
            appState.xp = remainingXP;
            await saveWalletXP(appState.address, remainingXP);
            
            // Try to get updated balance
            try {
              const newBalance = await dogTokenContract.balanceOf(appState.address);
              const formattedBalance = ethers.utils.formatEther(newBalance);
              
              document.getElementById('userDogBalance').textContent = parseFloat(formattedBalance).toFixed(2);
              document.getElementById('dogTokenBalance').textContent = parseFloat(formattedBalance).toFixed(2);
            } catch (e) {
              console.log('Could not fetch balance, will update on next refresh');
            }
            
            // Update total claimed stats
            await updateClaimedStats();
            
            // Save claim history
            await saveClaimHistory(appState.address, {
              xpAmount: xpToClaim,
              tokenAmount: claimableDOG,
              txHash: tx.hash
            });
            
            // Update UI
            await updateXPDisplay();
            showStatus('claim-status', `✅ Successfully claimed ${claimableDOG} $DOG tokens!`, 'success');
            
            // Show achievement
            showAchievementModal({
              icon: '💰',
              title: 'Tokens Claimed!',
              description: `You've successfully claimed ${claimableDOG} $DOG tokens! They are now in your wallet.`,
              type: 'claim',
              data: { amount: claimableDOG }
            });
            
            setTimeout(() => hideStatus('claim-status'), 5000);
            
          } catch (e) {
            console.log('Post-claim update error:', e);
            // Still show success since transaction was sent
            await updateXPDisplay();
            showStatus('claim-status', `✅ Claim transaction sent! Tokens will arrive soon.`, 'success');
            setTimeout(() => hideStatus('claim-status'), 5000);
          }
        }, 5000);
        
      } catch (error) {
        console.error('❌ Claim error:', error);
        let errorMsg = 'Failed to claim tokens';
        
        if (error.message.includes('user rejected')) {
          errorMsg = 'Transaction cancelled';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient gas funds';
        } else if (error.message.includes('XP already claimed')) {
          errorMsg = 'This XP has already been claimed';
        } else if (error.message.includes('Invalid XP amount')) {
          errorMsg = 'Invalid XP amount. Must be multiple of 10';
        }
        
        showStatus('claim-status', errorMsg, 'error');
        setTimeout(() => hideStatus('claim-status'), 5000);
      }
    };
    
    // Update claimed stats - Fixed version
    async function updateClaimedStats() {
      if (!appState.connected || !appState.provider) return;
      
      try {
        const dogTokenContract = new ethers.Contract(
          CONTRACTS.DOG_TOKEN,
          [
            "function getClaimedXP(address user) public view returns (uint256)",
            "function totalMinted() public view returns (uint256)",
            "function totalSupply() public view returns (uint256)"
          ],
          appState.provider
        );
        
        // Get user's claimed XP
        try {
          const claimedXP = await dogTokenContract.getClaimedXP(appState.address);
          const claimedXPNumber = parseInt(claimedXP.toString());
          const claimedDOG = claimedXPNumber / XP_TO_DOG_RATE;
          
          document.getElementById('totalClaimedXP').textContent = `${claimedXPNumber} XP`;
          document.getElementById('totalDogClaimed').textContent = `${claimedDOG} $DOG`;
        } catch (e) {
          console.log('Could not fetch user claimed XP');
          document.getElementById('totalClaimedXP').textContent = '0 XP';
          document.getElementById('totalDogClaimed').textContent = '0 $DOG';
        }
        
        // Get total minted supply for progress bar
        try {
          const totalMinted = await dogTokenContract.totalMinted();
          const totalSupply = await dogTokenContract.totalSupply();
          
          // DOG token has 18 decimals
          const mintedAmount = parseFloat(ethers.utils.formatUnits(totalMinted, 18));
          const maxSupply = parseFloat(ethers.utils.formatUnits(totalSupply, 18));
          
          // Update progress bar
          const percentage = maxSupply > 0 ? (mintedAmount / maxSupply) * 100 : 0;
          document.getElementById('claimedProgressBar').style.width = Math.min(percentage, 100) + '%';
          
          // Format numbers for display
          const formattedMinted = mintedAmount >= 1000000 ? 
            (mintedAmount / 1000000).toFixed(2) + 'M' : 
            mintedAmount >= 1000 ? 
            (mintedAmount / 1000).toFixed(1) + 'K' : 
            mintedAmount.toFixed(0);
          
          const formattedMax = maxSupply >= 1000000 ? 
            (maxSupply / 1000000).toFixed(0) + 'M' : 
            maxSupply.toFixed(0);
            
          document.getElementById('claimedProgressText').textContent = `${formattedMinted} / ${formattedMax}`;
          document.getElementById('totalClaimedAmount').textContent = mintedAmount.toLocaleString(undefined, {maximumFractionDigits: 0});
          
          console.log(`📊 Total minted: ${mintedAmount}, Max supply: ${maxSupply}`);
          
        } catch (e) {
          console.log('Could not fetch total minted:', e);
          // Set default values
          document.getElementById('claimedProgressBar').style.width = '0%';
          document.getElementById('claimedProgressText').textContent = '0 / 10M';
          document.getElementById('totalClaimedAmount').textContent = '0';
        }
        
      } catch (e) {
        console.log('Could not fetch claimed stats:', e);
      }
    }

    // Contract interaction tracking with Supabase - optimized
    async function getContractInteractions(address) {
      const defaultData = {
        pet: 0,
        gm: 0,
        gn: 0,
        flip: 0,
        total: 0,
        firstInteraction: null,
        lastInteraction: null
      };
      
      if (!address) return defaultData;
      
      // Get from localStorage first (immediate)
      const localData = localStorage.getItem(`contract_interactions_${address.toLowerCase()}`);
      if (!supabaseClient && localData) {
        return JSON.parse(localData) || defaultData;
      }
      
      try {
        const { data, error } = await supabaseClient
          .from('contract_interactions')
          .select('*')
          .eq('wallet_address', address.toLowerCase())
          .single();
        
        if (error || !data) {
          return localData ? JSON.parse(localData) || defaultData : defaultData;
        }
        
        return {
          pet: data.pet_count || 0,
          gm: data.gm_count || 0,
          gn: data.gn_count || 0,
          flip: data.flip_count || 0,
          total: data.total_interactions || 0,
          firstInteraction: data.first_interaction,
          lastInteraction: data.last_interaction
        };
      } catch (e) {
        console.error('Error fetching interactions:', e);
        return localData ? JSON.parse(localData) || defaultData : defaultData;
      }
    }

    async function saveContractInteraction(address, contractType) {
      try {
        // Get current data
        const currentData = await getContractInteractions(address);
        
        // Increment the specific interaction
        const updates = {
          wallet_address: address.toLowerCase(),
          pet_count: currentData.pet + (contractType === 'pet' ? 1 : 0),
          gm_count: currentData.gm + (contractType === 'gm' ? 1 : 0),
          gn_count: currentData.gn + (contractType === 'gn' ? 1 : 0),
          flip_count: currentData.flip + (contractType === 'flip' ? 1 : 0),
          last_interaction: new Date().toISOString()
        };
        
        updates.total_interactions = updates.pet_count + updates.gm_count + updates.gn_count + updates.flip_count;
        
        if (!currentData.firstInteraction) {
          updates.first_interaction = new Date().toISOString();
        }
        
        // Save to localStorage first (immediate)
        const localData = {
          pet: updates.pet_count,
          gm: updates.gm_count,
          gn: updates.gn_count,
          flip: updates.flip_count,
          total: updates.total_interactions,
          lastInteraction: updates.last_interaction,
          firstInteraction: updates.first_interaction || currentData.firstInteraction
        };
        localStorage.setItem(`contract_interactions_${address.toLowerCase()}`, JSON.stringify(localData));
        
        // Then try Supabase (non-blocking)
        if (supabaseClient) {
          supabaseClient
            .from('contract_interactions')
            .upsert(updates, {
              onConflict: 'wallet_address'
            })
            .then(({ error }) => {
              if (!error) {
                console.log(`📊 Contract interaction saved: ${contractType} for ${address}`);
                // Don't await - refresh leaderboard in background
                populateLeaderboard();
              }
            })
            .catch(e => {
              console.error('Error saving interaction:', e);
            });
        }
        
        return localData;
      } catch (e) {
        console.error('Error saving interaction:', e);
        return currentData;
      }
    }

    async function getAllContractInteractions() {
      // First check localStorage for immediate response
      const allUsers = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('contract_interactions_')) {
          const address = key.replace('contract_interactions_', '');
          const data = JSON.parse(localStorage.getItem(key));
          if (data && data.total > 0) {
            allUsers.push({
              address: address,
              ...data
            });
          }
        }
      }
      
      // If Supabase is available, fetch from there too
      if (supabaseClient) {
        try {
          const { data, error } = await supabaseClient
            .from('contract_interactions')
            .select('*')
            .order('total_interactions', { ascending: false })
            .limit(50);
          
          if (!error && data) {
            return data.map(user => ({
              address: user.wallet_address,
              pet: user.pet_count || 0,
              gm: user.gm_count || 0,
              gn: user.gn_count || 0,
              flip: user.flip_count || 0,
              total: user.total_interactions || 0,
              firstInteraction: user.first_interaction,
              lastInteraction: user.last_interaction
            }));
          }
        } catch (e) {
          console.error('Error fetching all interactions:', e);
        }
      }
      
      // Return localStorage data if Supabase fails
      allUsers.sort((a, b) => b.total - a.total);
      return allUsers;
    }

    function getBadgeForInteractions(interactions) {
      const { total } = interactions;
      
      if (total >= 100) return "Legend";
      if (total >= 50) return "Master";
      if (total >= 25) return "Expert"; 
      if (total >= 10) return "Active";
      if (total >= 5) return "Regular";
      if (total >= 1) return "Newbie";
      return "";
    }

    function getActivityBadge(interactions) {
      const { pet, gm, gn, flip } = interactions;
      
      if (pet >= 20) return "Dog Lover 🐕";
      if (gm + gn >= 30) return "Community Spirit 👋";
      if (flip >= 25) return "Lucky Gambler 🎰";
      if (pet >= 10 && gm + gn >= 10 && flip >= 10) return "All-Rounder ⭐";
      
      return "";
    }

    function getContractType(contractAddress, methodName) {
      if (contractAddress === CONTRACTS.PET && methodName === 'pet') return 'pet';
      if (contractAddress === CONTRACTS.GREET && methodName === 'gm') return 'gm';
      if (contractAddress === CONTRACTS.GREET && methodName === 'gn') return 'gn';
      if (contractAddress === CONTRACTS.FLIP && methodName === 'flip') return 'flip';
      return 'unknown';
    }

    // Global state 
    let appState = {
      connected: false,
      address: null,
      xp: 0,
      provider: null,
      signer: null
    };

    // Initialize SDK
    let sdk = null;
    
    async function initApp() {
      // Use the enhanced initialization with progress
      await initializeAppWithProgress();
    }

    function setupEventListeners() {
      document.getElementById('connect-btn').onclick = connectWallet;
      document.getElementById('disconnect-btn').onclick = disconnect;
    }

    function setupGameFunctions() {
      // Define all game functions globally
      window.petDog = async function() {
        console.log('🐕 Pet Dog clicked!');
        
        if (!appState.connected) {
          console.log('❌ Wallet not connected');
          showError('Connect wallet first');
          return;
        }
        
        console.log('✅ Wallet connected, starting pet transaction');
        
        // Change dog image
        document.getElementById('dog-img').src = `https://placedog.net/400/300?id=${Math.floor(Math.random() * 50) + 1}`;
        
        // Execute real blockchain transaction
        await executeTransaction(
          CONTRACTS.PET,
          ABIS.PET,
          'pet',
          'pet-status',
          '🐕 Dog petted successfully! +10 XP',
          10
        );
      };

      window.sayGM = async function() {
        console.log('☀️ Say GM clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gm',
          'greet-status',
          '☀️ Good Morning sent! +5 XP',
          5
        );
      };

      window.sayGN = async function() {
        console.log('🌙 Say GN clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gn',
          'greet-status',
          '🌙 Good Night sent! +5 XP',
          5
        );
      };

      window.flipCoin = async function() {
        console.log('🪙 Flip Coin clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        const coin = document.getElementById('coin');
        const result = document.getElementById('flip-result');
        
        // Start visual animation
        result.textContent = 'Flipping...';
        let rotation = 0;
        const interval = setInterval(() => {
          rotation += 180;
          coin.style.transform = `rotateY(${rotation}deg)`;
        }, 100);
        
        // Execute real transaction
        await executeTransaction(
          CONTRACTS.FLIP,
          ABIS.FLIP,
          'flip',
          'flip-status',
          '🪙 Coin flipped! +3 XP',
          3
        );
        
        // Stop animation after transaction starts
        setTimeout(() => {
          clearInterval(interval);
          const finalResult = Math.random() < 0.5 ? 'Heads' : 'Tails';
          coin.style.transform = `rotateY(${finalResult === 'Heads' ? 0 : 180}deg)`;
          result.textContent = `Result: ${finalResult}!`;
        }, 3000);
      };

      window.showTab = function(tabName) {
        console.log('📑 Switching to tab:', tabName);
        activeTab = tabName;
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');
        
        // Update claim UI when switching to claim tab
        if (tabName === 'claim') {
          updateClaimUI();
        }
      };

      console.log('🎮 Game functions setup complete');
    }

    function hideLoading() {
      // Legacy function - now uses enhanced loading state
      hideLoadingState();
    }

    async function connectWallet() {
      try {
        console.log('Connecting wallet...');
        
        // Show loading state
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = '🔄 Connecting...';
        connectBtn.disabled = true;
        
        let provider;
        
        if (sdk && sdk.wallet && sdk.wallet.ethProvider) {
          console.log('Using Farcaster wallet');
          provider = sdk.wallet.ethProvider;
        } else if (window.ethereum) {
          console.log('Using browser wallet');
          provider = window.ethereum;
        } else {
          throw new Error('No wallet available');
        }

        // Request accounts with timeout
        const accountsPromise = provider.request({
          method: 'eth_requestAccounts'
        });
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection timeout')), 10000)
        );
        
        const accounts = await Promise.race([accountsPromise, timeoutPromise]);

        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }

        console.log('✅ Connected:', accounts[0]);

        // Setup ethers
        appState.provider = new ethers.providers.Web3Provider(provider);
        appState.signer = appState.provider.getSigner();
        appState.address = accounts[0];
        appState.connected = true;

        // Update UI first
        updateWalletUI();
        
        // Then load data asynchronously
        updateXPDisplay().catch(console.error);

      } catch (error) {
        console.error('Connection error:', error);
        showError(error.message);
        
        // Reset button
        const connectBtn = document.getElementById('connect-btn');
        connectBtn.textContent = '🟣 Connect Wallet';
        connectBtn.disabled = false;
      }
    }

    async function disconnect() {
      appState = {
        connected: false,
        address: null,
        xp: 0,
        provider: null,
        signer: null
      };
      updateWalletUI();
      await updateXPDisplay();
      console.log('🔌 Wallet disconnected, XP reset to 0');
    }

    function updateWalletUI() {
      const connectArea = document.getElementById('connect-area');
      const connectedArea = document.getElementById('connected-area');
      const addressEl = document.getElementById('address');

      if (appState.connected) {
        connectArea.style.display = 'none';
        connectedArea.style.display = 'block';
        addressEl.textContent = appState.address.slice(0,6) + '...' + appState.address.slice(-4);
      } else {
        connectArea.style.display = 'block';
        connectedArea.style.display = 'none';
      }
    }

    async function addXP(amount) {
      if (!appState.connected || !appState.address) {
        console.log('❌ Cannot add XP: wallet not connected');
        return;
      }
      
      // Add XP to current wallet
      appState.xp += amount;
      
      // Update display immediately
      document.getElementById('xp').textContent = appState.xp;
      
      // Save to Supabase in background (non-blocking)
      saveWalletXP(appState.address, appState.xp);
      
      // Update claim UI non-blocking
      requestAnimationFrame(() => updateClaimUI());
      
      // Add celebration effect
      const xpElement = document.getElementById('xp');
      xpElement.style.transform = 'scale(1.2)';
      xpElement.style.color = '#00ff00';
      
      setTimeout(() => {
        xpElement.style.transform = 'scale(1)';
        xpElement.style.color = 'white';
      }, 500);
      
      console.log(`✨ XP added to ${appState.address}: +${amount}, Total: ${appState.xp}`);
    }

    function showStatus(id, message, type) {
      const el = document.getElementById(id);
      el.textContent = message;
      el.className = `status visible ${type}`;
    }

    function hideStatus(id) {
      document.getElementById(id).className = 'status';
    }

    function showError(message) {
      const div = document.createElement('div');
      div.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:10px 20px;border-radius:8px;z-index:1000;';
      div.textContent = message;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 5000);
    }

    // Real transaction function
    async function executeTransaction(contractAddress, abi, methodName, statusId, successMsg, xpAmount) {
      if (!appState.connected) {
        showError('Connect wallet first');
        return;
      }

      try {
        console.log('🔗 Starting transaction:', methodName);
        showStatus(statusId, 'Preparing transaction...', 'pending');

        // Ensure Monad network
        await ensureMonadNetwork();

        // Create contract instance
        const contract = new ethers.Contract(contractAddress, abi, appState.signer);
        
        showStatus(statusId, '🔐 Please confirm in your wallet...', 'pending');

        // Send transaction
        const tx = await contract[methodName]({
          gasLimit: 1000000
        });

        console.log('✅ Transaction sent:', tx.hash);
        showStatus(statusId, `✅ Transaction sent: ${tx.hash.slice(0,10)}...`, 'pending');

        // Since Farcaster wallet doesn't support eth_getTransactionReceipt,
        // we'll assume success after a delay and track the interaction
        setTimeout(async () => {
          console.log('✅ Transaction assumed successful');
          showStatus(statusId, successMsg, 'success');
          await addXP(xpAmount);
          
          // Track contract interaction
          if (appState.connected && appState.address) {
            const contractType = getContractType(contractAddress, methodName);
            const interactionData = await saveContractInteraction(appState.address, contractType);
            console.log(`🎯 Contract interaction tracked: ${contractType}`);
            
            // Check for achievements
            checkAndShowAchievements(contractType, interactionData);
          }
          
          setTimeout(() => hideStatus(statusId), 3000);
        }, 5000);

      } catch (error) {
        console.error('❌ Transaction error:', error);
        
        let errorMsg = 'Transaction failed';
        if (error.message.includes('user rejected') || error.code === 4001) {
          errorMsg = 'Transaction cancelled by user';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient funds for gas';
        }

        showStatus(statusId, errorMsg, 'error');
        setTimeout(() => hideStatus(statusId), 5000);
      }
    }

    async function ensureMonadNetwork() {
      const MONAD_CHAIN_ID = '0x279F'; // 10143 in hex
      
      try {
        const provider = sdk && sdk.wallet && sdk.wallet.ethProvider 
          ? sdk.wallet.ethProvider 
          : window.ethereum;

        if (!provider) {
          throw new Error('No wallet provider available');
        }

        const chainId = await provider.request({ method: 'eth_chainId' });
        console.log('Current chain ID:', chainId);

        if (chainId !== MONAD_CHAIN_ID) {
          console.log('Switching to Monad Testnet...');
          
          try {
            await provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: MONAD_CHAIN_ID }],
            });
            console.log('Switched to Monad Testnet');
          } catch (switchError) {
            if (switchError.code === 4902) {
              console.log('Adding Monad Testnet...');
              await provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: MONAD_CHAIN_ID,
                  chainName: 'Monad Testnet',
                  nativeCurrency: {
                    name: 'Monad',
                    symbol: 'MONAD',
                    decimals: 18
                  },
                  rpcUrls: ['https://testnet-rpc.monad.xyz'],
                  blockExplorerUrls: ['https://testnet.monadscan.com/']
                }]
              });
              console.log('Monad Testnet added');
            }
          }

          // Recreate provider after network switch
          appState.provider = new ethers.providers.Web3Provider(provider);
          appState.signer = appState.provider.getSigner();
        }
      } catch (error) {
        console.error('Network switch error:', error);
        throw new Error('Failed to switch to Monad Testnet');
      }
    }

    async function populateLeaderboard() {
      const tbody = document.getElementById('leaderboardBody');
      if (!tbody) return;

      // Show loading state
      tbody.innerHTML = `
        <tr>
          <td colspan="3" style="text-align: center; padding: 20px; color: rgba(255,255,255,0.7);">
            Loading contract interactions...
          </td>
        </tr>
      `;

      try {
        // Get all contract interactions from Supabase
        const contractUsers = await getAllContractInteractions();
        
        console.log('📊 Found', contractUsers.length, 'users with contract interactions');
        
        if (contractUsers.length === 0) {
          tbody.innerHTML = `
            <tr>
              <td colspan="3" style="text-align: center; padding: 40px; color: rgba(255,255,255,0.7);">
                <div>🌟 Be the first to interact!</div>
                <div style="font-size: 11px; opacity: 0.7; margin-top: 8px;">
                  Pet the dog, say GM/GN, or flip coins to appear here
                </div>
              </td>
            </tr>
          `;
          return;
        }
        
        // Create leaderboard with contract interaction data
        const leaderboardData = contractUsers.map((user, index) => ({
          rank: index + 1,
          address: user.address,
          txCount: user.total,
          interactions: {
            pet: user.pet,
            gm: user.gm,
            gn: user.gn,
            flip: user.flip
          },
          badge: getBadgeForInteractions(user),
          activityBadge: getActivityBadge(user)
        }));
        
        // Populate table
        tbody.innerHTML = leaderboardData.map((item) => {
          const isCurrentUser = appState.connected && 
            item.address.toLowerCase() === appState.address?.toLowerCase();
          
          const interactionDetails = `🐕${item.interactions.pet} 👋${item.interactions.gm + item.interactions.gn} 🪙${item.interactions.flip}`;
          
          return `
            <tr style="${isCurrentUser ? 'background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.5);' : ''}" 
                title="Pet: ${item.interactions.pet}, GM/GN: ${item.interactions.gm + item.interactions.gn}, Flip: ${item.interactions.flip}">
              <td class="rank-number">#${item.rank}</td>
              <td class="address-cell">
                <div>${item.address.slice(0,6)}...${item.address.slice(-4)}</div>
                <div style="font-size: 10px; opacity: 0.7; margin-top: 2px;">${interactionDetails}</div>
                ${item.activityBadge ? `<span class="badge" style="background: #ff6b9d;">${item.activityBadge}</span>` : ''}
                ${isCurrentUser ? '<span class="badge" style="background: #10b981;">You</span>' : ''}
              </td>
              <td class="tx-count">${item.txCount}</td>
            </tr>
          `;
        }).join('');

        console.log('✅ Leaderboard populated with contract interaction data');

      } catch (error) {
        console.error('❌ Error populating leaderboard:', error);
        
        tbody.innerHTML = `
          <tr>
            <td colspan="3" style="text-align: center; padding: 20px; color: #ff6b6b;">
              ⚠️ Failed to load leaderboard data
            </td>
          </tr>
        `;
      }
    }

    window.refreshLeaderboard = async function() {
      console.log('🔄 Refreshing Monad Dog leaderboard...');
      await populateLeaderboard();
      console.log('✅ Leaderboard refreshed with latest contract interactions');
    };

    // Farcaster Sharing Functions
    function generateShareableContent(type, data = {}) {
      const baseUrl = window.location.origin;
      const userStats = appState.connected ? getContractInteractions(appState.address) : null;
      const tokenBalance = document.getElementById('dogTokenBalance')?.textContent || '0';
      
      const shareTemplates = {
        pet: {
          text: `Just petted the Monad Dog! 🐕✨\n\nTotal pets: ${userStats?.pet || 0}\nXP earned: ${appState.xp}\n$DOG Balance: ${tokenBalance}\n\nJoin me on Monad Testnet!`,
          url: `${baseUrl}?ref=pet&xp=${appState.xp}`,
          image: "🐕"
        },
        greet: {
          text: `GM Monad community! ☀️👋\n\nTotal greetings: ${(userStats?.gm || 0) + (userStats?.gn || 0)}\nCommunity XP: ${appState.xp}\n$DOG Tokens: ${tokenBalance}\n\nSpread the love on Monad!`,
          url: `${baseUrl}?ref=greet&xp=${appState.xp}`,
          image: "👋"
        },
        flip: {
          text: `Just flipped a coin on Monad! 🪙\n\nResult: ${data.result || 'Lucky'}\nTotal flips: ${userStats?.flip || 0}\nXP: ${appState.xp}\n$DOG: ${tokenBalance}`,
          url: `${baseUrl}?ref=flip&result=${data.result}&xp=${appState.xp}`,
          image: "🪙"
        },
        claim: {
          text: `Just claimed ${data.amount || 0} $DOG tokens! 💰\n\nTotal $DOG Balance: ${tokenBalance}\nXP remaining: ${appState.xp}\n\nEarn XP and claim your $DOG tokens too!`,
          url: `${baseUrl}?ref=claim&tokens=${data.amount}`,
          image: "💰"
        },
        leaderboard: {
          text: `Check out my Monad Dog stats! 🏆\n\nRank: ${data.rank || '?'}\nTotal interactions: ${userStats?.total || 0}\nXP: ${appState.xp}\n$DOG Tokens: ${tokenBalance}\n\nCan you beat me?`,
          url: `${baseUrl}?ref=leaderboard&rank=${data.rank}&xp=${appState.xp}`,
          image: "🏆"
        },
        invite: {
          text: `Playing Monad Dog - the cutest way to explore Monad Testnet! 🐕⛓️\n\n✨ Pet dogs, flip coins, say GM/GN\n🎯 Earn XP and claim $DOG tokens\n💰 Convert XP to tokens (10:1 rate)\n🚀 Real blockchain interactions\n\nJoin me!`,
          url: `https://monad-snowy.vercel.app?ref=invite&inviter=${appState.address?.slice(0,6)}`,
          image: "🚀"
        }
      };
      
      return shareTemplates[type] || shareTemplates.invite;
    }

    function shareOnFarcaster(content) {
      try {
        if (sdk && sdk.actions && sdk.actions.openUrl) {
          // Use Farcaster SDK for sharing
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          sdk.actions.openUrl(shareUrl);
          console.log('🚀 Shared via Farcaster SDK');
        } else {
          // Fallback to direct URL
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          window.open(shareUrl, '_blank');
          console.log('🚀 Shared via direct URL');
        }
        
        // Track sharing event
        console.log('📊 Share event tracked:', content);
        
      } catch (error) {
        console.error('❌ Share error:', error);
        showError('Failed to open share dialog');
      }
    }

    // Achievement Modal Functions
    function showAchievementModal(achievement) {
      const modal = document.getElementById('achievementModal');
      const icon = document.getElementById('achievementIcon');
      const title = document.getElementById('achievementTitle');
      const description = document.getElementById('achievementDescription');
      
      icon.textContent = achievement.icon;
      title.textContent = achievement.title;
      description.textContent = achievement.description;
      
      modal.style.display = 'flex';
      
      // Store current achievement for sharing
      window.currentAchievement = achievement;
      
      console.log('🎉 Achievement modal shown:', achievement);
    }

    function closeAchievementModal() {
      document.getElementById('achievementModal').style.display = 'none';
      window.currentAchievement = null;
    }

    function shareCurrentAchievement() {
      if (window.currentAchievement) {
        const content = generateShareableContent(window.currentAchievement.type, window.currentAchievement.data);
        shareOnFarcaster(content);
        closeAchievementModal();
      }
    }

    // Individual Share Functions
    window.sharePetAchievement = async function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const userStats = await getContractInteractions(appState.address);
      const achievement = {
        icon: '🐕',
        title: 'Dog Lover Achievement!',
        description: `You've petted the dog ${userStats.pet} times and earned ${appState.xp} XP!`,
        type: 'pet',
        data: { pets: userStats.pet }
      };
      
      showAchievementModal(achievement);
    };

    window.shareGreetAchievement = async function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const userStats = await getContractInteractions(appState.address);
      const totalGreets = userStats.gm + userStats.gn;
      const achievement = {
        icon: '👋',
        title: 'Community Spirit!',
        description: `You've greeted the community ${totalGreets} times! Spreading love on Monad.`,
        type: 'greet',
        data: { greets: totalGreets }
      };
      
      showAchievementModal(achievement);
    };

    window.shareFlipAchievement = async function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const userStats = await getContractInteractions(appState.address);
      const lastResult = document.getElementById('flip-result').textContent;
      const achievement = {
        icon: '🪙',
        title: 'Lucky Flipper!',
        description: `${lastResult} You've flipped ${userStats.flip} coins on Monad!`,
        type: 'flip',
        data: { flips: userStats.flip, result: lastResult }
      };
      
      showAchievementModal(achievement);
    };

    window.shareLeaderboardPosition = async function() {
      if (!appState.connected) {
        showError('Connect wallet to share position');
        return;
      }
      
      // Find user's position in leaderboard
      const allUsers = await getAllContractInteractions();
      const userIndex = allUsers.findIndex(user => 
        user.address.toLowerCase() === appState.address.toLowerCase()
      );
      
      const rank = userIndex >= 0 ? userIndex + 1 : '?';
      const userStats = await getContractInteractions(appState.address);
      
      const achievement = {
        icon: '🏆',
        title: 'Leaderboard Position!',
        description: `Rank #${rank} with ${userStats.total} total interactions and ${appState.xp} XP!`,
        type: 'leaderboard',
        data: { rank, total: userStats.total }
      };
      
      showAchievementModal(achievement);
    };

    window.shareAppWithFriends = function() {
      const achievement = {
        icon: '🚀',
        title: 'Invite Friends!',
        description: 'Share Monad Dog with your friends and build the community together!',
        type: 'invite',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    // Auto-show achievements after major milestones
    function checkAndShowAchievements(interactionType, userStats) {
      const achievements = [];
      
      // Pet milestones
      if (interactionType === 'pet') {
        if (userStats.pet === 1) {
          achievements.push({
            icon: '🐕',
            title: 'First Pet!',
            description: 'You petted your first Monad Dog! Welcome to the pack!',
            type: 'pet'
          });
        } else if (userStats.pet === 10) {
          achievements.push({
            icon: '🐕',
            title: 'Dog Whisperer!',
            description: '10 pets! The dogs love you!',
            type: 'pet'
          });
        } else if (userStats.pet === 50) {
          achievements.push({
            icon: '🐕',
            title: 'Dog Master!',
            description: '50 pets! You are a true dog lover!',
            type: 'pet'
          });
        }
      }
      
      // Community milestones
      if (interactionType === 'gm' || interactionType === 'gn') {
        const totalGreets = userStats.gm + userStats.gn;
        if (totalGreets === 1) {
          achievements.push({
            icon: '👋',
            title: 'First Greeting!',
            description: 'Welcome to the Monad community!',
            type: 'greet'
          });
        } else if (totalGreets === 25) {
          achievements.push({
            icon: '👋',
            title: 'Community Champion!',
            description: '25 greetings! You spread so much positivity!',
            type: 'greet'
          });
        }
      }
      
      // Flip milestones
      if (interactionType === 'flip') {
        if (userStats.flip === 1) {
          achievements.push({
            icon: '🪙',
            title: 'First Flip!',
            description: 'Your first coin flip on Monad! Feeling lucky?',
            type: 'flip'
          });
        } else if (userStats.flip === 20) {
          achievements.push({
            icon: '🪙',
            title: 'High Roller!',
            description: '20 flips! Lady luck is on your side!',
            type: 'flip'
          });
        }
      }
      
      // XP milestones
      const totalXP = appState.xp;
      if (totalXP >= 100 && !localStorage.getItem(`xp_milestone_100_${appState.address}`)) {
        achievements.push({
          icon: '✨',
          title: 'XP Milestone!',
          description: '100 XP earned! You can now claim 10 $DOG tokens!',
          type: 'xp'
        });
        localStorage.setItem(`xp_milestone_100_${appState.address}`, 'true');
      }
      
      // Show first achievement if any
      if (achievements.length > 0) {
        setTimeout(() => {
          showAchievementModal(achievements[0]);
        }, 2000); // Show after transaction success message
      }
    }

    // Start app when DOM is ready with preloading
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        preloadResources();
        initApp();
      });
    } else {
      preloadResources();
      initApp();
    }

    console.log('📱 App script loaded');
    }); // End of DOMContentLoaded
  </script>
</body>
</html>
