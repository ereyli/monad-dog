<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monad Dog</title>
  
  <!-- Farcaster Meta with Dynamic Content -->
  <meta name="fc:frame" content='{
    "version": "next",
    "imageUrl": "https://monad-snowy.vercel.app/.well-known/icon.png",
    "button": {
      "title": "üêï Play Monad Dog",
      "action": {
        "type": "launch_frame",
        "url": "https://monad-dog.vercel.app",
        "name": "Monad Dog",
        "splashImageUrl": "https://monad-snowy.vercel.app/.well-known/icon.png",
        "splashBackgroundColor": "#1e003e"
      }
    }
  }' />

  <!-- Open Graph for better sharing -->
  <meta property="og:title" content="Monad Dog - Pet, Greet, Flip on Monad Testnet" />
  <meta property="og:description" content="Interactive Farcaster Mini App on Monad Testnet. Pet the dog, say GM/GN, flip coins and earn XP!" />
  <meta property="og:image" content="https://monad-dog.vercel.app/share.png" />
  <meta property="og:url" content="https://monad-snowy.vercel.app/" />
  <meta name="twitter:card" content="summary_large_image" />

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 400px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .xp {
      background: rgba(255,255,255,0.1);
      padding: 10px 20px;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 20px;
    }
    
    .wallet-section {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      margin: 10px 0;
    }
    
    button:hover {
      background: #5855e8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tabs {
      display: flex;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    .tab {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    
    .tab.active {
      background: #6366f1;
    }
    
    .content {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      min-height: 200px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .dog-image {
      width: 200px;
      height: 200px;
      border-radius: 12px;
      margin: 20px auto;
      display: block;
    }
    
    .coin {
      font-size: 60px;
      margin: 20px;
      transition: transform 0.5s;
    }
    
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      display: none;
    }
    
    .status.visible {
      display: block;
    }
    
    .status.success {
      background: rgba(0,255,0,0.2);
      color: #00ff00;
    }
    
    .status.error {
      background: rgba(255,0,0,0.2);
      color: #ff6b6b;
    }
    
    .status.pending {
      background: rgba(255,255,0,0.2);
      color: #ffeb3b;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      color: white;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      border-top-color: #6366f1;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    .loading-subtitle {
      font-size: 14px;
      opacity: 0.7;
      text-align: center;
      max-width: 280px;
      line-height: 1.4;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      margin-top: 20px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Skeleton Loading States */
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-text {
      height: 16px;
      border-radius: 4px;
      margin: 8px 0;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .skeleton-button {
      height: 44px;
      border-radius: 8px;
      margin: 10px 0;
    }

    /* Hide content initially to prevent layout shift */
    .app-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .app-content.loaded {
      opacity: 1;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    
    th {
      background: rgba(255,255,255,0.1);
    }
    
    .address {
      font-family: monospace;
      font-size: 12px;
    }

    .badge {
      background: #ff6b9d;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 8px;
    }

    .rank-number {
      font-weight: 600;
      color: #6366f1;
      width: 40px;
    }

    .address-cell {
      font-family: monospace;
      font-size: 12px;
    }

    .share-button {
      background: linear-gradient(45deg, #6366f1, #8b5cf6);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin: 10px 5px;
      width: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .share-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
    }

    .share-section {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .achievement-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    .achievement-content {
      background: linear-gradient(135deg, #1e003e 0%, #330066 100%);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 350px;
      border: 2px solid #6366f1;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }

    .achievement-icon {
      font-size: 60px;
      margin-bottom: 15px;
      animation: bounce 0.6s ease;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      width: auto;
      padding: 5px;
    }
  </style>
</head>
<body>
  <div class="container app-content">
    <div class="header">
      <div class="title">üêï Monad Dog</div>
      <div class="xp">‚ú® XP: <span id="xp">0</span></div>
    </div>

    <div class="wallet-section">
      <div id="connect-area">
        <button id="connect-btn">üü£ Connect Wallet</button>
      </div>
      <div id="connected-area" style="display: none;">
        <div>üü£ Connected</div>
        <div id="address" class="address"></div>
        <button id="disconnect-btn">Disconnect</button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="showTab('pet')">üêï Pet</button>
      <button class="tab" onclick="showTab('greet')">üëã Greet</button>
      <button class="tab" onclick="showTab('flip')">ü™ô Flip</button>
      <button class="tab" onclick="showTab('leaderboard')">üèÜ Ranks</button>
    </div>

    <div class="content">
      <!-- Pet Tab -->
      <div id="pet" class="tab-content active">
        <h3>Pet the Dog</h3>
        <img id="dog-img" class="dog-image" src="https://placedog.net/400/300?id=7" alt="Dog">
        <button onclick="petDog()">üëã Pet Dog (+10 XP)</button>
        <div id="pet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="sharePetAchievement()">
            üêï Share Pet Achievement
          </button>
        </div>
      </div>

      <!-- Greet Tab -->
      <div id="greet" class="tab-content">
        <h3>Greet Community</h3>
        <p>Say GM or GN to the community!</p>
        <button onclick="sayGM()">‚òÄÔ∏è Good Morning (+5 XP)</button>
        <button onclick="sayGN()">üåô Good Night (+5 XP)</button>
        <div id="greet-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareGreetAchievement()">
            üëã Share Community Spirit
          </button>
        </div>
      </div>

      <!-- Flip Tab -->
      <div id="flip" class="tab-content">
        <h3>Flip Coin</h3>
        <div class="coin" id="coin">ü™ô</div>
        <button onclick="flipCoin()">üé≤ Flip Coin (+3 XP)</button>
        <div id="flip-result">Result will appear here</div>
        <div id="flip-status" class="status"></div>
        
        <div class="share-section">
          <button class="share-button" onclick="shareFlipAchievement()">
            ü™ô Share Lucky Moment
          </button>
        </div>
      </div>

      <!-- Leaderboard Tab -->
      <div id="leaderboard" class="tab-content">
        <h3>Monad Dog Leaderboard</h3>
        <p style="font-size: 12px; opacity: 0.7; margin-bottom: 15px;">Top players by contract interactions</p>
        <table>
          <thead>
            <tr><th>Rank</th><th>Address</th><th>Interactions</th></tr>
          </thead>
          <tbody id="leaderboardBody">
            <!-- Populated by JavaScript -->
          </tbody>
        </table>
        <button onclick="refreshLeaderboard()" style="margin-top: 16px; width: auto; padding: 8px 16px; font-size: 12px;">
          üîÑ Refresh
        </button>
        
        <div class="share-section">
          <button class="share-button" onclick="shareLeaderboardPosition()">
            üèÜ Share My Ranking
          </button>
          <button class="share-button" onclick="shareAppWithFriends()">
            üöÄ Invite Friends
          </button>
        </div>
      </div>
    </div>

    <div id="loading" class="loading">Loading...</div>

    <!-- Achievement Modal -->
    <div id="achievementModal" class="achievement-modal">
      <div class="achievement-content">
        <button class="close-modal" onclick="closeAchievementModal()">√ó</button>
        <div id="achievementIcon" class="achievement-icon">üéâ</div>
        <h3 id="achievementTitle">Achievement Unlocked!</h3>
        <p id="achievementDescription">You did something awesome!</p>
        <div style="margin-top: 20px;">
          <button class="share-button" onclick="shareCurrentAchievement()">
            üì¢ Share on Farcaster
          </button>
          <button class="share-button" onclick="closeAchievementModal()" style="background: rgba(255,255,255,0.2);">
            ‚ú® Continue Playing
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    console.log('üöÄ Starting app...');
    
    // Enhanced Loading Management
    let loadingProgress = 0;
    let isAppReady = false;

    function updateLoadingProgress(progress, message) {
      const progressBar = document.getElementById('loadingProgressBar');
      const subtitle = document.querySelector('.loading-subtitle');
      
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
      
      if (subtitle && message) {
        subtitle.innerHTML = message;
      }
      
      loadingProgress = progress;
      console.log(`üìä Loading progress: ${progress}% - ${message}`);
    }

    function showLoadingState() {
      document.getElementById('loading').style.display = 'flex';
      document.querySelector('.app-content').classList.remove('loaded');
      updateLoadingProgress(0, 'Starting Monad Dog...<br>üöÄ Initializing blockchain connection');
    }

    function hideLoadingState() {
      // Don't hide immediately - show completion
      updateLoadingProgress(100, 'Ready to play! üéâ<br>Welcome to Monad Dog!');
      
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.querySelector('.app-content').classList.add('loaded');
        isAppReady = true;
        
        // Call Farcaster ready action
        if (sdk && sdk.actions && sdk.actions.ready) {
          sdk.actions.ready({
            disableNativeGestures: false // Allow native gestures for better UX
          }).then(() => {
            console.log('‚úÖ Farcaster SDK ready called successfully');
          }).catch(error => {
            console.log('‚ö†Ô∏è Farcaster SDK ready failed:', error);
          });
        }
        
        console.log('üéâ App fully loaded and ready');
      }, 500);
    }

    // Simulate progressive loading with actual initialization steps
    async function initializeAppWithProgress() {
      try {
        showLoadingState();
        
        // Step 1: Initialize SDK
        updateLoadingProgress(20, 'Loading Farcaster SDK...<br>üîó Connecting to Frame environment');
        
        try {
          const module = await import('https://esm.sh/@farcaster/frame-sdk');
          sdk = module.sdk;
          console.log('SDK loaded:', !!sdk);
          
          if (sdk) {
            updateLoadingProgress(40, 'Farcaster SDK loaded! ‚úÖ<br>üì± Setting up Mini App environment');
            await sdk.actions.ready();
            console.log('SDK ready');
          }
        } catch (e) {
          console.log('SDK not available:', e.message);
          updateLoadingProgress(40, 'Running in standalone mode<br>üåê Browser environment detected');
        }

        // Step 2: Setup game functions
        updateLoadingProgress(60, 'Setting up game functions...<br>üéÆ Preparing blockchain interactions');
        await new Promise(resolve => setTimeout(resolve, 300)); // Small delay for UX
        
        setupEventListeners();
        setupGameFunctions();
        
        // Step 3: Load leaderboard
        updateLoadingProgress(80, 'Loading leaderboard data...<br>üèÜ Fetching player rankings');
        await populateLeaderboard();
        
        // Step 4: Finalize
        updateLoadingProgress(95, 'Almost ready...<br>‚ú® Final preparations');
        await new Promise(resolve => setTimeout(resolve, 200));
        
        hideLoadingState();
        console.log('‚úÖ App initialized successfully with progress tracking');
        
      } catch (error) {
        console.error('‚ùå Init error:', error);
        updateLoadingProgress(100, 'Error occurred, but app will continue<br>‚ö†Ô∏è Some features may be limited');
        
        setTimeout(() => {
          hideLoadingState();
        }, 1000);
      }
    }

    // Enhanced error handling for better loading experience
    function handleLoadingError(error, step) {
      console.error(`‚ùå Loading error at step "${step}":`, error);
      
      const errorMessages = {
        sdk: 'SDK loading failed<br>üåê Continuing in browser mode',
        functions: 'Function setup error<br>‚ö†Ô∏è Some features may be limited',
        leaderboard: 'Leaderboard loading failed<br>üìä Will retry automatically',
        general: 'Loading error occurred<br>üîÑ Attempting to continue'
      };
      
      const message = errorMessages[step] || errorMessages.general;
      updateLoadingProgress(loadingProgress, message);
      
      // Continue loading after brief delay
      setTimeout(() => {
        if (loadingProgress < 100) {
          hideLoadingState();
        }
      }, 1500);
    }

    // Skeleton loading for leaderboard while data loads
    function showLeaderboardSkeleton() {
      const tbody = document.getElementById('leaderboardBody');
      if (!tbody) return;
      
      const skeletonRows = Array.from({length: 5}, (_, i) => `
        <tr>
          <td class="rank-number skeleton skeleton-text" style="width: 30px;"></td>
          <td class="address-cell">
            <div class="skeleton skeleton-text" style="width: 120px;"></div>
            <div class="skeleton skeleton-text" style="width: 80px; margin-top: 4px;"></div>
          </td>
          <td class="tx-count skeleton skeleton-text" style="width: 40px;"></td>
        </tr>
      `).join('');
      
      tbody.innerHTML = skeletonRows;
    }

    // Preload critical resources
    function preloadResources() {
      // Preload dog images for faster switching
      const dogImages = [1, 7, 12, 15, 23, 28, 34, 42, 47, 53];
      dogImages.forEach(id => {
        const img = new Image();
        img.src = `https://placedog.net/400/300?id=${id}`;
      });
      
      console.log('üñºÔ∏è Preloaded dog images for better performance');
    }

    // Contract addresses and ABIs
    const CONTRACTS = {
      PET: "0xc53abe4c593b9440407f8ac1b346f3f999e6d8ed",
      GREET: "0xbc8b78f3e2348d4b5e0390fe700ce54b59931da4",
      FLIP: "0xc5b2280d1e2f155f9a2be2af7e78190658874106"
    };

    const ABIS = {
      PET: ["function pet() public"],
      GREET: ["function gm() public", "function gn() public"],
      FLIP: ["function flip() public"]
    };

    // Wallet-specific XP management
    function getWalletXP(address) {
      if (!address) return 0;
      const key = `wallet_xp_${address.toLowerCase()}`;
      return parseInt(localStorage.getItem(key) || '0');
    }

    function saveWalletXP(address, xp) {
      if (!address) return;
      const key = `wallet_xp_${address.toLowerCase()}`;
      localStorage.setItem(key, xp.toString());
      console.log(`üíæ XP saved for ${address}: ${xp}`);
    }

    function updateXPDisplay() {
      if (appState.connected && appState.address) {
        const walletXP = getWalletXP(appState.address);
        document.getElementById('xp').textContent = walletXP;
        appState.xp = walletXP;
        console.log(`üìä XP loaded for ${appState.address}: ${walletXP}`);
      } else {
        document.getElementById('xp').textContent = '0';
        appState.xp = 0;
      }
    }

    // Contract interaction tracking
    function getContractInteractions(address) {
      const key = `contract_interactions_${address.toLowerCase()}`;
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : {
        pet: 0,
        gm: 0,
        gn: 0,
        flip: 0,
        total: 0,
        firstInteraction: null,
        lastInteraction: null
      };
    }

    function saveContractInteraction(address, contractType) {
      const key = `contract_interactions_${address.toLowerCase()}`;
      const data = getContractInteractions(address);
      
      data[contractType] = (data[contractType] || 0) + 1;
      data.total = data.pet + data.gm + data.gn + data.flip;
      data.lastInteraction = new Date().toISOString();
      
      if (!data.firstInteraction) {
        data.firstInteraction = new Date().toISOString();
      }
      
      localStorage.setItem(key, JSON.stringify(data));
      
      console.log(`üìä Contract interaction saved: ${contractType} for ${address}`);
      console.log(`üìà Total interactions: ${data.total}`);
      
      return data;
    }

    function getAllContractInteractions() {
      const allUsers = [];
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('contract_interactions_')) {
          const address = key.replace('contract_interactions_', '');
          const data = JSON.parse(localStorage.getItem(key));
          
          if (data.total > 0) {
            allUsers.push({
              address: address,
              ...data
            });
          }
        }
      }
      
      allUsers.sort((a, b) => b.total - a.total);
      return allUsers;
    }

    function getBadgeForInteractions(interactions) {
      const { total } = interactions;
      
      if (total >= 100) return "Legend";
      if (total >= 50) return "Master";
      if (total >= 25) return "Expert"; 
      if (total >= 10) return "Active";
      if (total >= 5) return "Regular";
      if (total >= 1) return "Newbie";
      return "";
    }

    function getActivityBadge(interactions) {
      const { pet, gm, gn, flip } = interactions;
      
      if (pet >= 20) return "Dog Lover üêï";
      if (gm + gn >= 30) return "Community Spirit üëã";
      if (flip >= 25) return "Lucky Gambler üé∞";
      if (pet >= 10 && gm + gn >= 10 && flip >= 10) return "All-Rounder ‚≠ê";
      
      return "";
    }

    function getContractType(contractAddress, methodName) {
      if (contractAddress === CONTRACTS.PET && methodName === 'pet') return 'pet';
      if (contractAddress === CONTRACTS.GREET && methodName === 'gm') return 'gm';
      if (contractAddress === CONTRACTS.GREET && methodName === 'gn') return 'gn';
      if (contractAddress === CONTRACTS.FLIP && methodName === 'flip') return 'flip';
      return 'unknown';
    }

    // Global state 
    let appState = {
      connected: false,
      address: null,
      xp: 0,
      provider: null,
      signer: null
    };

    // Initialize SDK
    let sdk = null;
    
    async function initApp() {
      // Use the enhanced initialization with progress
      await initializeAppWithProgress();
    }

    function setupEventListeners() {
      document.getElementById('connect-btn').onclick = connectWallet;
      document.getElementById('disconnect-btn').onclick = disconnect;
    }

    function setupGameFunctions() {
      // Define all game functions globally
      window.petDog = async function() {
        console.log('üêï Pet Dog clicked!');
        
        if (!appState.connected) {
          console.log('‚ùå Wallet not connected');
          showError('Connect wallet first');
          return;
        }
        
        console.log('‚úÖ Wallet connected, starting pet transaction');
        
        // Change dog image
        document.getElementById('dog-img').src = `https://placedog.net/400/300?id=${Math.floor(Math.random() * 50) + 1}`;
        
        // Execute real blockchain transaction
        await executeTransaction(
          CONTRACTS.PET,
          ABIS.PET,
          'pet',
          'pet-status',
          'üêï Dog petted successfully! +10 XP',
          10
        );
      };

      window.sayGM = async function() {
        console.log('‚òÄÔ∏è Say GM clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gm',
          'greet-status',
          '‚òÄÔ∏è Good Morning sent! +5 XP',
          5
        );
      };

      window.sayGN = async function() {
        console.log('üåô Say GN clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        await executeTransaction(
          CONTRACTS.GREET,
          ABIS.GREET,
          'gn',
          'greet-status',
          'üåô Good Night sent! +5 XP',
          5
        );
      };

      window.flipCoin = async function() {
        console.log('ü™ô Flip Coin clicked!');
        
        if (!appState.connected) {
          showError('Connect wallet first');
          return;
        }
        
        const coin = document.getElementById('coin');
        const result = document.getElementById('flip-result');
        
        // Start visual animation
        result.textContent = 'Flipping...';
        let rotation = 0;
        const interval = setInterval(() => {
          rotation += 180;
          coin.style.transform = `rotateY(${rotation}deg)`;
        }, 100);
        
        // Execute real transaction
        await executeTransaction(
          CONTRACTS.FLIP,
          ABIS.FLIP,
          'flip',
          'flip-status',
          'ü™ô Coin flipped! +3 XP',
          3
        );
        
        // Stop animation after transaction starts
        setTimeout(() => {
          clearInterval(interval);
          const finalResult = Math.random() < 0.5 ? 'Heads' : 'Tails';
          coin.style.transform = `rotateY(${finalResult === 'Heads' ? 0 : 180}deg)`;
          result.textContent = `Result: ${finalResult}!`;
        }, 3000);
      };

      window.showTab = function(tabName) {
        console.log('üìë Switching to tab:', tabName);
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');
      };

      console.log('üéÆ Game functions setup complete');
    }

    function hideLoading() {
      // Legacy function - now uses enhanced loading state
      hideLoadingState();
    }

    async function connectWallet() {
      try {
        console.log('Connecting wallet...');
        
        let provider;
        
        if (sdk && sdk.wallet && sdk.wallet.ethProvider) {
          console.log('Using Farcaster wallet');
          provider = sdk.wallet.ethProvider;
        } else if (window.ethereum) {
          console.log('Using browser wallet');
          provider = window.ethereum;
        } else {
          throw new Error('No wallet available');
        }

        // Request accounts
        const accounts = await provider.request({
          method: 'eth_requestAccounts'
        });

        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts found');
        }

        console.log('‚úÖ Connected:', accounts[0]);

        // Setup ethers
        appState.provider = new ethers.providers.Web3Provider(provider);
        appState.signer = appState.provider.getSigner();
        appState.address = accounts[0];
        appState.connected = true;

        // Update UI and load wallet-specific XP
        updateWalletUI();
        updateXPDisplay();

      } catch (error) {
        console.error('Connection error:', error);
        showError(error.message);
      }
    }

    function disconnect() {
      appState = {
        connected: false,
        address: null,
        xp: 0,
        provider: null,
        signer: null
      };
      updateWalletUI();
      updateXPDisplay();
      console.log('üîå Wallet disconnected, XP reset to 0');
    }

    function updateWalletUI() {
      const connectArea = document.getElementById('connect-area');
      const connectedArea = document.getElementById('connected-area');
      const addressEl = document.getElementById('address');

      if (appState.connected) {
        connectArea.style.display = 'none';
        connectedArea.style.display = 'block';
        addressEl.textContent = appState.address.slice(0,6) + '...' + appState.address.slice(-4);
      } else {
        connectArea.style.display = 'block';
        connectedArea.style.display = 'none';
      }
    }

    function addXP(amount) {
      if (!appState.connected || !appState.address) {
        console.log('‚ùå Cannot add XP: wallet not connected');
        return;
      }
      
      // Add XP to current wallet
      appState.xp += amount;
      
      // Save to localStorage for this specific wallet
      saveWalletXP(appState.address, appState.xp);
      
      // Update display
      document.getElementById('xp').textContent = appState.xp;
      
      // Add celebration effect
      const xpElement = document.getElementById('xp');
      xpElement.style.transform = 'scale(1.2)';
      xpElement.style.color = '#00ff00';
      
      setTimeout(() => {
        xpElement.style.transform = 'scale(1)';
        xpElement.style.color = 'white';
      }, 500);
      
      console.log(`‚ú® XP added to ${appState.address}: +${amount}, Total: ${appState.xp}`);
    }

    function showStatus(id, message, type) {
      const el = document.getElementById(id);
      el.textContent = message;
      el.className = `status visible ${type}`;
    }

    function hideStatus(id) {
      document.getElementById(id).className = 'status';
    }

    function showError(message) {
      const div = document.createElement('div');
      div.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:10px 20px;border-radius:8px;z-index:1000;';
      div.textContent = message;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 5000);
    }

    // Real transaction function
    async function executeTransaction(contractAddress, abi, methodName, statusId, successMsg, xpAmount) {
      if (!appState.connected) {
        showError('Connect wallet first');
        return;
      }

      try {
        console.log('üîó Starting transaction:', methodName);
        showStatus(statusId, 'Preparing transaction...', 'pending');

        // Ensure Monad network
        await ensureMonadNetwork();

        // Create contract instance
        const contract = new ethers.Contract(contractAddress, abi, appState.signer);
        
        showStatus(statusId, 'üîê Please confirm in your wallet...', 'pending');

        // Send transaction
        const tx = await contract[methodName]({
          gasLimit: 1000000
        });

        console.log('‚úÖ Transaction sent:', tx.hash);
        showStatus(statusId, `‚úÖ Transaction sent: ${tx.hash.slice(0,10)}...`, 'pending');

        // Since Farcaster wallet doesn't support eth_getTransactionReceipt,
        // we'll assume success after a delay and track the interaction
        setTimeout(() => {
          console.log('‚úÖ Transaction assumed successful');
          showStatus(statusId, successMsg, 'success');
          addXP(xpAmount);
          
          // Track contract interaction
          if (appState.connected && appState.address) {
            const contractType = getContractType(contractAddress, methodName);
            const interactionData = saveContractInteraction(appState.address, contractType);
            console.log(`üéØ Contract interaction tracked: ${contractType}`);
            
            // Check for achievements
            checkAndShowAchievements(contractType, interactionData);
          }
          
          setTimeout(() => hideStatus(statusId), 3000);
        }, 5000);

      } catch (error) {
        console.error('‚ùå Transaction error:', error);
        
        let errorMsg = 'Transaction failed';
        if (error.message.includes('user rejected') || error.code === 4001) {
          errorMsg = 'Transaction cancelled by user';
        } else if (error.message.includes('insufficient funds')) {
          errorMsg = 'Insufficient funds for gas';
        }

        showStatus(statusId, errorMsg, 'error');
        setTimeout(() => hideStatus(statusId), 5000);
      }
    }

    async function ensureMonadNetwork() {
      const MONAD_CHAIN_ID = '0x279F'; // 10143 in hex
      
      try {
        const provider = sdk && sdk.wallet && sdk.wallet.ethProvider 
          ? sdk.wallet.ethProvider 
          : window.ethereum;

        if (!provider) {
          throw new Error('No wallet provider available');
        }

        const chainId = await provider.request({ method: 'eth_chainId' });
        console.log('Current chain ID:', chainId);

        if (chainId !== MONAD_CHAIN_ID) {
          console.log('Switching to Monad Testnet...');
          
          try {
            await provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: MONAD_CHAIN_ID }],
            });
            console.log('Switched to Monad Testnet');
          } catch (switchError) {
            if (switchError.code === 4902) {
              console.log('Adding Monad Testnet...');
              await provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: MONAD_CHAIN_ID,
                  chainName: 'Monad Testnet',
                  nativeCurrency: {
                    name: 'Monad',
                    symbol: 'MONAD',
                    decimals: 18
                  },
                  rpcUrls: ['https://testnet-rpc.monad.xyz'],
                  blockExplorerUrls: ['https://testnet.monadscan.com/']
                }]
              });
              console.log('Monad Testnet added');
            }
          }

          // Recreate provider after network switch
          appState.provider = new ethers.providers.Web3Provider(provider);
          appState.signer = appState.provider.getSigner();
        }
      } catch (error) {
        console.error('Network switch error:', error);
        throw new Error('Failed to switch to Monad Testnet');
      }
    }

    async function populateLeaderboard() {
      const tbody = document.getElementById('leaderboardBody');
      if (!tbody) return;

      // Show loading state
      tbody.innerHTML = `
        <tr>
          <td colspan="3" style="text-align: center; padding: 20px; color: rgba(255,255,255,0.7);">
            Loading contract interactions...
          </td>
        </tr>
      `;

      try {
        // Get all contract interactions from localStorage
        const contractUsers = getAllContractInteractions();
        
        console.log('üìä Found', contractUsers.length, 'users with contract interactions');
        
        if (contractUsers.length === 0) {
          tbody.innerHTML = `
            <tr>
              <td colspan="3" style="text-align: center; padding: 40px; color: rgba(255,255,255,0.7);">
                <div>üåü Be the first to interact!</div>
                <div style="font-size: 11px; opacity: 0.7; margin-top: 8px;">
                  Pet the dog, say GM/GN, or flip coins to appear here
                </div>
              </td>
            </tr>
          `;
          return;
        }
        
        // Create leaderboard with contract interaction data
        const leaderboardData = contractUsers.map((user, index) => ({
          rank: index + 1,
          address: user.address,
          txCount: user.total,
          interactions: {
            pet: user.pet,
            gm: user.gm,
            gn: user.gn,
            flip: user.flip
          },
          badge: getBadgeForInteractions(user),
          activityBadge: getActivityBadge(user)
        }));
        
        // Populate table
        tbody.innerHTML = leaderboardData.map((item) => {
          const isCurrentUser = appState.connected && 
            item.address.toLowerCase() === appState.address?.toLowerCase();
          
          const interactionDetails = `üêï${item.interactions.pet} üëã${item.interactions.gm + item.interactions.gn} ü™ô${item.interactions.flip}`;
          
          return `
            <tr style="${isCurrentUser ? 'background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.5);' : ''}" 
                title="Pet: ${item.interactions.pet}, GM/GN: ${item.interactions.gm + item.interactions.gn}, Flip: ${item.interactions.flip}">
              <td class="rank-number">#${item.rank}</td>
              <td class="address-cell">
                <div>${item.address.slice(0,6)}...${item.address.slice(-4)}</div>
                <div style="font-size: 10px; opacity: 0.7; margin-top: 2px;">${interactionDetails}</div>
                ${item.activityBadge ? `<span class="badge" style="background: #ff6b9d;">${item.activityBadge}</span>` : ''}
                ${isCurrentUser ? '<span class="badge" style="background: #10b981;">You</span>' : ''}
              </td>
              <td class="tx-count">${item.txCount}</td>
            </tr>
          `;
        }).join('');

        console.log('‚úÖ Leaderboard populated with contract interaction data');

      } catch (error) {
        console.error('‚ùå Error populating leaderboard:', error);
        
        tbody.innerHTML = `
          <tr>
            <td colspan="3" style="text-align: center; padding: 20px; color: #ff6b6b;">
              ‚ö†Ô∏è Failed to load leaderboard data
            </td>
          </tr>
        `;
      }
    }

    window.refreshLeaderboard = async function() {
      console.log('üîÑ Refreshing Monad Dog leaderboard...');
      await populateLeaderboard();
      console.log('‚úÖ Leaderboard refreshed with latest contract interactions');
    };

    // Farcaster Sharing Functions
    function generateShareableContent(type, data = {}) {
      const baseUrl = window.location.origin;
      const userStats = appState.connected ? getContractInteractions(appState.address) : null;
      
      const shareTemplates = {
        pet: {
          text: `Just petted the Monad Dog! üêï‚ú®\n\nTotal pets: ${userStats?.pet || 0}\nXP earned: ${appState.xp}\n\nJoin me on Monad Testnet!`,
          url: `${baseUrl}?ref=pet&xp=${appState.xp}`,
          image: "üêï"
        },
        greet: {
          text: `GM Monad community! ‚òÄÔ∏èüëã\n\nTotal greetings: ${(userStats?.gm || 0) + (userStats?.gn || 0)}\nCommunity XP: ${appState.xp}\n\nSpread the love on Monad!`,
          url: `${baseUrl}?ref=greet&xp=${appState.xp}`,
          image: "üëã"
        },
        flip: {
          text: `Just flipped a coin on Monad! ü™ô\n\nResult: ${data.result || 'Lucky'}\nTotal flips: ${userStats?.flip || 0}\nXP: ${appState.xp}`,
          url: `${baseUrl}?ref=flip&result=${data.result}&xp=${appState.xp}`,
          image: "ü™ô"
        },
        leaderboard: {
          text: `Check out my Monad Dog stats! üèÜ\n\nRank: ${data.rank || '?'}\nTotal interactions: ${userStats?.total || 0}\nXP: ${appState.xp}\n\nCan you beat me?`,
          url: `${baseUrl}?ref=leaderboard&rank=${data.rank}&xp=${appState.xp}`,
          image: "üèÜ"
        },
        invite: {
          text: `Playing Monad Dog - the cutest way to explore Monad Testnet! üêï‚õìÔ∏è\n\n‚ú® Pet dogs, flip coins, say GM/GN\nüéØ Earn XP and climb leaderboards\nüöÄ Real blockchain interactions\n\nJoin me!`,
          url: `${baseUrl}?ref=invite&inviter=${appState.address?.slice(0,6)}`,
          image: "üöÄ"
        }
      };
      
      return shareTemplates[type] || shareTemplates.invite;
    }

    function shareOnFarcaster(content) {
      try {
        if (sdk && sdk.actions && sdk.actions.openUrl) {
          // Use Farcaster SDK for sharing
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          sdk.actions.openUrl(shareUrl);
          console.log('üöÄ Shared via Farcaster SDK');
        } else {
          // Fallback to direct URL
          const shareUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(content.text)}&embeds[]=${encodeURIComponent(content.url)}`;
          window.open(shareUrl, '_blank');
          console.log('üöÄ Shared via direct URL');
        }
        
        // Track sharing event
        console.log('üìä Share event tracked:', content);
        
      } catch (error) {
        console.error('‚ùå Share error:', error);
        showError('Failed to open share dialog');
      }
    }

    // Achievement Modal Functions
    function showAchievementModal(achievement) {
      const modal = document.getElementById('achievementModal');
      const icon = document.getElementById('achievementIcon');
      const title = document.getElementById('achievementTitle');
      const description = document.getElementById('achievementDescription');
      
      icon.textContent = achievement.icon;
      title.textContent = achievement.title;
      description.textContent = achievement.description;
      
      modal.style.display = 'flex';
      
      // Store current achievement for sharing
      window.currentAchievement = achievement;
      
      console.log('üéâ Achievement modal shown:', achievement);
    }

    function closeAchievementModal() {
      document.getElementById('achievementModal').style.display = 'none';
      window.currentAchievement = null;
    }

    function shareCurrentAchievement() {
      if (window.currentAchievement) {
        const content = generateShareableContent(window.currentAchievement.type, window.currentAchievement.data);
        shareOnFarcaster(content);
        closeAchievementModal();
      }
    }

    // Individual Share Functions
    window.sharePetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const userStats = getContractInteractions(appState.address);
      const achievement = {
        icon: 'üêï',
        title: 'Dog Lover Achievement!',
        description: `You've petted the dog ${userStats.pet} times and earned ${appState.xp} XP!`,
        type: 'pet',
        data: { pets: userStats.pet }
      };
      
      showAchievementModal(achievement);
    };

    window.shareGreetAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const userStats = getContractInteractions(appState.address);
      const totalGreets = userStats.gm + userStats.gn;
      const achievement = {
        icon: 'üëã',
        title: 'Community Spirit!',
        description: `You've greeted the community ${totalGreets} times! Spreading love on Monad.`,
        type: 'greet',
        data: { greets: totalGreets }
      };
      
      showAchievementModal(achievement);
    };

    window.shareFlipAchievement = function() {
      if (!appState.connected) {
        showError('Connect wallet to share achievements');
        return;
      }
      
      const userStats = getContractInteractions(appState.address);
      const lastResult = document.getElementById('flip-result').textContent;
      const achievement = {
        icon: 'ü™ô',
        title: 'Lucky Flipper!',
        description: `${lastResult} You've flipped ${userStats.flip} coins on Monad!`,
        type: 'flip',
        data: { flips: userStats.flip, result: lastResult }
      };
      
      showAchievementModal(achievement);
    };

    window.shareLeaderboardPosition = function() {
      if (!appState.connected) {
        showError('Connect wallet to share position');
        return;
      }
      
      // Find user's position in leaderboard
      const allUsers = getAllContractInteractions();
      const userIndex = allUsers.findIndex(user => 
        user.address.toLowerCase() === appState.address.toLowerCase()
      );
      
      const rank = userIndex >= 0 ? userIndex + 1 : '?';
      const userStats = getContractInteractions(appState.address);
      
      const achievement = {
        icon: 'üèÜ',
        title: 'Leaderboard Position!',
        description: `Rank #${rank} with ${userStats.total} total interactions and ${appState.xp} XP!`,
        type: 'leaderboard',
        data: { rank, total: userStats.total }
      };
      
      showAchievementModal(achievement);
    };

    window.shareAppWithFriends = function() {
      const achievement = {
        icon: 'üöÄ',
        title: 'Invite Friends!',
        description: 'Share Monad Dog with your friends and build the community together!',
        type: 'invite',
        data: {}
      };
      
      showAchievementModal(achievement);
    };

    // Auto-show achievements after major milestones
    function checkAndShowAchievements(interactionType, userStats) {
      const achievements = [];
      
      // Pet milestones
      if (interactionType === 'pet') {
        if (userStats.pet === 1) {
          achievements.push({
            icon: 'üêï',
            title: 'First Pet!',
            description: 'You petted your first Monad Dog! Welcome to the pack!',
            type: 'pet'
          });
        } else if (userStats.pet === 10) {
          achievements.push({
            icon: 'üêï',
            title: 'Dog Whisperer!',
            description: '10 pets! The dogs love you!',
            type: 'pet'
          });
        } else if (userStats.pet === 50) {
          achievements.push({
            icon: 'üêï',
            title: 'Dog Master!',
            description: '50 pets! You are a true dog lover!',
            type: 'pet'
          });
        }
      }
      
      // Community milestones
      if (interactionType === 'gm' || interactionType === 'gn') {
        const totalGreets = userStats.gm + userStats.gn;
        if (totalGreets === 1) {
          achievements.push({
            icon: 'üëã',
            title: 'First Greeting!',
            description: 'Welcome to the Monad community!',
            type: 'greet'
          });
        } else if (totalGreets === 25) {
          achievements.push({
            icon: 'üëã',
            title: 'Community Champion!',
            description: '25 greetings! You spread so much positivity!',
            type: 'greet'
          });
        }
      }
      
      // Flip milestones
      if (interactionType === 'flip') {
        if (userStats.flip === 1) {
          achievements.push({
            icon: 'ü™ô',
            title: 'First Flip!',
            description: 'Your first coin flip on Monad! Feeling lucky?',
            type: 'flip'
          });
        } else if (userStats.flip === 20) {
          achievements.push({
            icon: 'ü™ô',
            title: 'High Roller!',
            description: '20 flips! Lady luck is on your side!',
            type: 'flip'
          });
        }
      }
      
      // Show first achievement if any
      if (achievements.length > 0) {
        setTimeout(() => {
          showAchievementModal(achievements[0]);
        }, 2000); // Show after transaction success message
      }
    }
    window.resetXP = function() {
      if (!appState.connected || !appState.address) {
        console.log('‚ùå No wallet connected to reset XP');
        return;
      }
      
      appState.xp = 0;
      saveWalletXP(appState.address, 0);
      document.getElementById('xp').textContent = '0';
      console.log(`üîÑ XP reset to 0 for wallet ${appState.address}`);
    };

    window.checkXP = function() {
      if (!appState.connected || !appState.address) {
        console.log('‚ùå No wallet connected');
        return 0;
      }
      
      console.log(`üíé Current XP for ${appState.address}:`, appState.xp);
      console.log(`üíæ Stored XP:`, getWalletXP(appState.address));
      return appState.xp;
    };

    window.getAllWalletsXP = function() {
      const allWallets = {};
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('wallet_xp_')) {
          const address = key.replace('wallet_xp_', '');
          const xp = parseInt(localStorage.getItem(key));
          allWallets[address] = xp;
        }
      }
      
      console.log('üéØ All wallets XP:', allWallets);
      return allWallets;
    };

    function showTab(tabName) {
      // Update tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // Update content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName).classList.add('active');
    }

    // Start app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }

    console.log('üì± App script loaded');
  </script>
</body>
</html>
